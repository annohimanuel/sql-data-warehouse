# Exploring the database 
SELECT 
	* 
FROM 
	INFORMATION_SCHEMA.COLUMNS
WHERE 
	TABLE_SCHEMA IN ('Bronze','Silver','Gold');
    
# Exploring the columns in my database
SELECT 
	* 
FROM 
	INFORMATION_SCHEMA.COLUMNS
WHERE 
	TABLE_SCHEMA IN ('Bronze','Silver','Gold');
    
# Dimension exploration

-- Exploring the countries the customers are from

SELECT DISTINCT country FROM gold.dim_customers;  # seven countries 

-- Exploring the distinct catories and subcategory of the business process 

SELECT category, COUNT(DISTINCT subcategory) FROM gold.dim_products
GROUP BY category;     # Four main product categories, each with subcategories ; Accessories with 12 subcat and components with 13 

SELECT category,subcategory,product_name FROM gold.dim_products 
ORDER BY 1,2,3;    # More indepth granularity of the products sold 

# Date exploration 

-- Exploring the first and last order date in the dataset 

SELECT 
	MIN(order_date) AS first_order_date,
    MAX(order_date) AS last_order_date 
FROM 
	gold.fact_sales;    # We have four years span of orders from 2010 to 2014 
    
-- Exploring the youngest and oldest customner and their respective ages 

SELECT 
	MIN(birth_date) AS oldest_customer, 
    TIMESTAMPDIFF(YEAR,MIN(birth_date), CURRENT_DATE()) AS oldest_age, # 109yrs 
	MAX(birth_date) AS youngest_customer,
    TIMESTAMPDIFF(YEAR,MAX(birth_date), CURRENT_DATE()) AS youngest_age # 39yrs
FROM 
	gold.dim_customers;


# Measures Exploration 

-- Exploring the total sales of the business 

SELECT SUM(sales_amount) FROM gold.fact_sales; # $29M

-- Exploring total number of orders

SELECT COUNT(*) AS num_of_transctions FROM gold.fact_sales; # 60k orders
SELECT COUNT(DISTINCT order_number) FROM gold.fact_sales;  # 28k distinct orders

-- Exploring average sellling price 

SELECT AVG(sales_amount) FROM gold.fact_sales; # $486

-- Exploring how many items were sold 

SELECT COUNT(DISTINCT product_name) FROM gold.dim_products; # 295 products sold

-- A report for all these key measure metrics 

SELECT 'Total Sales' AS measure_name, SUM(sales_amount) AS measure_value FROM gold.fact_sales
UNION ALL
SELECT 'Total Quantity' AS measure_name, SUM(sales_quantity) AS measure_value FROM gold.fact_sales
UNION ALL 
SELECT 'Total Order' AS measure_name, COUNT(DISTINCT order_number) AS measure_value FROM gold.fact_sales
UNION ALL
SELECT 'Average Price' AS measure_name, AVG(sales_amount) AS measure_value FROM gold.fact_sales
UNION ALL 
SELECT 'Total Number of Customers' AS measure_name, COUNT(DISTINCT customer_key) AS measure_value FROM gold.fact_sales
UNION ALL 
SELECT 'Total Number of Products' AS measure_name, COUNT(DISTINCT product_name) FROM gold.dim_products;


# Magnitude Analysis 

-- Finding the total customers by countries 
SELECT country, COUNT(*) AS num_of_customers FROM gold.dim_customers
GROUP BY country 
ORDER BY 2 DESC;  # USA and Australia lead the way with 7500 and 3500 respectively 

-- Finding total customers by gender 
SELECT gender, COUNT(*) AS num_of_customers FROM gold.dim_customers
GROUP BY gender 
ORDER BY 2 DESC; # about even split (9341 M to 9128 F) 

--  Total products by category and subcat
SELECT category, subcategory, COUNT(DISTINCT product_id) AS num_of_products FROM gold.dim_products 
GROUP BY 1,2
ORDER BY 1 ASC,3 DESC;

-- Average costs in each category 

SELECT category, AVG(product_cost) AS average_cost FROM gold.dim_products 
GROUP BY category 
ORDER BY 2 DESC;

-- Find the total revenue generated by each customer

SELECT customer_key, SUM(sales_amount) FROM gold.fact_sales 
GROUP BY 1 
ORDER BY 2 DESC;

-- Find the total revenue generated by each category 

SELECT p.category, SUM(s.sales_amount) FROM gold.fact_sales s
LEFT JOIN gold.dim_products p
ON p.product_key = s.product_key
GROUP BY 1
ORDER BY 2 DESC; # bikes brings almost all the revenue $ 28M

-- What is the distribution of sold items across countires 

SELECT c.country, COUNT(s.order_number) FROM gold.fact_sales s 
LEFT JOIN gold.dim_customers c 
ON s.customer_key = c.customer_key 
GROUP BY 1
ORDER BY 2 DESC;


# Ranking Analysis 

-- Which five products regenerated the highest revenue 

SELECT p.product_name, SUM(s.sales_amount) FROM gold.fact_sales s
LEFT JOIN dim_products p 
ON s.product_key = p.product_key
GROUP BY 1
ORDER BY 2 DESC 
LIMIT 5; # Mountain 200 black and silver

-- Which five products performed worst in terms of sales
SELECT p.product_name, SUM(s.sales_amount) FROM gold.fact_sales s
LEFT JOIN dim_products p 
ON s.product_key = p.product_key
GROUP BY 1
ORDER BY 2 ASC 
LIMIT 5;


# Changes over time analysis 

-- Analyze the sales performance over time (year and month aggregates) 
SELECT 
	DATE_FORMAT(order_date,'%y-%m') AS year_order_date, 
    SUM(sales_amount) AS yearly_sales,
    COUNT(DISTINCT customer_key) AS total_customers
FROM 
	gold.fact_sales 
WHERE 
	order_date IS NOT NULL
GROUP BY 
	1
ORDER BY 
	1;


# Cumulative Analysis 

-- Calculate the total sales per month, the running totals of monthly sales through the years 

SELECT 
	monthly_order_dates,
    monthly_sales,
    SUM(monthly_sales) OVER (PARTITION BY DATE_FORMAT(monthly_order_dates, '%y') ORDER BY monthly_order_dates) AS running_total
FROM
 (
SELECT
	DATE_FORMAT(order_date,'%y-%m-01') as monthly_order_dates,
    SUM(sales_amount) as monthly_sales
    
FROM 
	gold.fact_sales
WHERE 
	DATE_FORMAT(order_date,'%y-%m') IS NOT NULL
GROUP BY 1
)t;


# Performance Analysis 

/* Analyze the yearly performance of products by comparing 
each products sales to both its avergae sales performance and previous year's sales */


WITH cte AS (
SELECT 
	p.product_name,
    YEAR(f.order_date) AS order_year,
    SUM(f.sales_amount) AS current_sales
FROM 
	gold.fact_sales f
LEFT JOIN 
	gold.dim_products p
ON 
	p.product_key = f.product_key 
WHERE YEAR(f.order_date) IS NOT NULL
GROUP BY 1,2
ORDER BY 1,2
)

SELECT
	product_name,
    order_year,
    current_sales,
    AVG(current_sales) OVER (PARTITION BY product_name) AS avg_product_sales,
    LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS prev_sales,
    ((current_sales) -  (AVG(current_sales) OVER (PARTITION BY product_name))) AS diff_avg,
    CASE WHEN 
     ((current_sales) -  (AVG(current_sales) OVER (PARTITION BY product_name))) > 0 THEN 'Good'
	WHEN 
      ((current_sales) -  (AVG(current_sales) OVER (PARTITION BY product_name))) = 0 THEN 'Neutral'
	WHEN 
	  ((current_sales) -  (AVG(current_sales) OVER (PARTITION BY product_name))) < 0 THEN 'Bad'
	ELSE 'n/a'
    END AS performance_review,
    CASE WHEN current_sales > LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) THEN 'Increase'
		 WHEN current_sales < LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year)  THEN 'Decrease'
	ELSE 'no change'
    END AS previous_year_change
FROM cte;


# Part to Whole Analysis

-- Which catgeories contribute the most to overall sales 

SELECT 
	category,
    total_sales,
    (total_sales/ (SELECT SUM(sales_amount) FROM gold.fact_sales)) as perc_total
FROM (
SELECT 
	p.category,
	SUM(f.sales_amount) AS total_sales
FROM 
	gold.fact_sales f
LEFT JOIN 
	gold.dim_products p 
ON 
	p.product_key = f.product_key
GROUP BY 
	p.category 
)t;


# Data Segmentation Analysis 

/* Segement products into cost ranges and count 
how many products fall in each category */

SELECT 
    cost_range,
    COUNT(*) AS num_products
FROM (

SELECT 
	product_key,
    product_name,
    product_cost,
    CASE WHEN product_cost < 100 THEN 'Below 100'
		 WHEN product_cost BETWEEN 100 AND 500 THEN '100-500'
		 WHEN product_cost BETWEEN 501 AND 1000 THEN '501-1000'
         ELSE 'Above 1000'
	END AS cost_range
FROM 
	gold.dim_products 
)t
GROUP BY 
	1
ORDER BY 
	1;


/* Group customers based on their spending behavior
VIP customers = At least 12 months of history and 5000 dollars total spend 
Regular customers = At least 12 months of history and less than 5000 dollars total spend 
New customers = lifespan less than 12 months
*/

WITH spending_behavior AS (
SELECT
	customer_key,
    SUM(num_orders) AS order_number,
    SUM(total_sales) as order_sales_customer
FROM (
SELECT 
	customer_key,
    order_date,
    SUM(sales_amount) as total_sales,
    COUNT(*) as num_orders
FROM 
	gold.fact_sales 
GROUP BY 
	1,2
ORDER BY 
	1
)t
GROUP BY customer_key ) 

SELECT 
	customer_key,
    order_number,
	CASE WHEN order_number >= 12 AND order_sales_customer >= 5000 THEN 'VIP'
    WHEN order_number >= 12 AND order_sales_customer < 5000 THEN 'Regular'
    ELSE 'New'
    END AS segmented_customers
FROM spending_behavior;


/*
==============================================================
Customer Report
==============================================================

Purpose:
  - This report consolidates key customer metrics and behaviors

Highlights:
  1. Gathers essential fields such as names, ages, and transaction details.
  2. Segments customers into categories (VIP, Regular, New) and age groups.
  3. Aggregates customer-level metrics:
     - total orders
     - total sales
     - total quantity purchased
     - total products
     - lifespan (in months)
  4. Calculates valuable KPIs:
     - recency (months since last order)
     - average order value
     - average monthly spend

==============================================================
*/

CREATE VIEW gold.report AS 
(
WITH base_query AS (
SELECT 
	f.product_key,
    f.customer_key,
    f.order_number,
    f.order_date,
    f.sales_quantity,
    f.sales_price,
    CONCAT(c.first_name, ' ', c.last_name) AS customer_fullname,
    c.birth_date,
    TIMESTAMPDIFF(YEAR, c.birth_date, CURDATE()) AS age_customer
FROM 
	gold.fact_sales f
LEFT JOIN 
	gold.dim_customers c
ON 
	c.customer_key = f.customer_key
WHERE 
	f.order_date IS NOT NULL),
agg_cte AS
(
SELECT 
	customer_key,
    customer_fullname,
    age_customer,
    COUNT(DISTINCT order_number) AS num_orders,
    SUM(sales_quantity) AS total_quantity,
    SUM(sales_price) AS total_sales,
    COUNT(DISTINCT product_key) AS num_products,
    MAX(order_date) AS last_order_date,
    TIMESTAMPDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan
FROM 
	base_query 
GROUP BY 
	customer_key,
    customer_fullname,
    age_customer
)

SELECT 
	customer_key,
    customer_fullname,
    age_customer,
    CASE WHEN age_customer < 20 THEN 'Under 20'
		WHEN age_customer BETWEEN 20 AND 29 THEN '20-29'
        WHEN age_customer BETWEEN 30 AND 39 THEN '30-39'
        WHEN age_customer BETWEEN 40 AND 59 THEN '40-59'
        ELSE '>50'
	END AS age_groups,
	num_orders,
    total_quantity,
	total_sales,
    ROUND((total_sales/num_orders),2) AS avg_order_value,
	ROUND((total_sales/lifespan),2) AS avg_monthly_spend,
    num_products,
    last_order_date,
    lifespan,
    TIMESTAMPDIFF(month,last_order_date,CURDATE()) AS recency_yrs,
    CASE WHEN lifespan >= 12 AND total_sales >= 5000 THEN 'VIP'
		 WHEN lifespan >= 12 AND total_sales < 5000 THEN 'Regular'
         ElSE 'New'
	END AS segment_customers
FROM 
	agg_cte
    
);


/*
========================================================================================================================
Product Report
========================================================================================================================

Purpose:
  - This report consolidates key product metrics and behaviors.

Highlights:
  1. Gathers essential fields such as product name, category, subcategory, and cost.
  2. Segments products by revenue to identify High-Performers, Mid-Range, or Low-Performers.
  3. Aggregates product-level metrics:
     - total orders
     - total sales
     - total quantity sold
     - total customers (unique)
     - lifespan (in months)
  4. Calculates valuable KPIs:
     - recency (months since last sale)
     - average order revenue (AOR)
     - average monthly revenue

========================================================================================================================
*/

ALTER VIEW gold.report_products AS
(
WITH base_query AS (
SELECT 
	f.product_key,
    f.customer_key,
    f.order_number,
    f.order_date,
    f.sales_price,
    f.sales_quantity,
	p.product_id, 
    p.category_id,
    p.product_name,
    p.product_cost,
    p.category,
    p.subcategory
FROM 
	gold.fact_sales f
LEFT JOIN 
	gold.dim_products p 
ON 
	p.product_key = f.product_key
),

agg_query AS (

SELECT 
	customer_key,
	product_key,
    product_name,
    category,
	subcategory,
    order_date,
    COUNT(DISTINCT order_number) AS total_orders,
    SUM(sales_price) AS total_sales,
    SUM(sales_quantity) AS total_quantity,
	COUNT(DISTINCT product_id) AS num_products, 
    SUM(product_cost) AS total_product_cost
FROM 
	base_query
GROUP BY 
	customer_key,
	product_key,
    product_name,
    category,
	subcategory,
    order_date
),

more_agg_query AS (

SELECT 
    product_name,
    product_key,
    MAX(order_date) AS last_order_date,
    MIN(order_date) AS first_order_date,
    COUNT(DISTINCT customer_key) AS num_customners_per_product_name,
    SUM(total_orders) AS total_products_for_each_product_name,
    SUM(total_sales) AS total_sales_for_each_product,
    SUM(total_quantity) AS total_quantity_sold_for_each_product,
    SUM(total_product_cost) AS total_product_cost_for_each_product
FROM 
	agg_query
GROUP BY 
	product_name,
    product_key
ORDER BY 
	product_name 
    
) 

SELECT
	product_name,
    product_key,
    TIMESTAMPDIFF(month,first_order_date,last_order_date) AS lifespan,
    num_customners_per_product_name AS total_customers,
    total_products_for_each_product_name AS total_products_sold,
    CASE WHEN total_sales_for_each_product > 10000 THEN 'High Performer'
		 WHEN total_sales_for_each_product BETWEEN 5000 AND 10000 THEN 'Mid Range'
         ELSE 'Low Performer'
	END AS product_segment,
    total_sales_for_each_product AS total_sales,
    TIMESTAMPDIFF(month,last_order_date,CURDATE()) AS recency,
    (total_sales_for_each_product/total_quantity_sold_for_each_product) AS average_order_revenue,
	(total_sales_for_each_product/TIMESTAMPDIFF(month,first_order_date,last_order_date)) AS average_monthly_revenue
FROM 
	more_agg_query 
);
    
    
CREATE VIEW gold.products_report_new AS 
WITH base AS (
  SELECT
    f.product_key,
    f.customer_key,
    f.order_number,
    f.order_date,
    f.sales_price,
    f.sales_quantity,
    p.product_name,
    p.category,
    p.subcategory,
    p.product_cost
  FROM gold.fact_sales f
  LEFT JOIN gold.dim_products p
    ON p.product_key = f.product_key
),
product_rollup AS (
  SELECT
    product_key,
    product_name,
    category,
    subcategory,
    MIN(order_date) AS first_order_date,
    MAX(order_date) AS last_order_date,
    COUNT(DISTINCT customer_key) AS total_customers,
    COUNT(DISTINCT order_number) AS total_orders,
    SUM(sales_quantity) AS total_quantity_sold,
    SUM(sales_quantity * sales_price) AS total_sales,  
    SUM(product_cost * sales_quantity) AS total_product_cost
  FROM base
  GROUP BY product_key, product_name, category, subcategory
)
SELECT
  product_name,
  product_key,
  category,
  subcategory,

  TIMESTAMPDIFF(MONTH, first_order_date, last_order_date) AS lifespan_months,
  total_customers,
  total_orders,
  total_quantity_sold,

  CASE
    WHEN total_sales > 10000 THEN 'High Performer'
    WHEN total_sales BETWEEN 5000 AND 10000 THEN 'Mid Range'
    ELSE 'Low Performer'
  END AS product_segment,

  total_sales,

  TIMESTAMPDIFF(MONTH, last_order_date, CURDATE()) AS recency_months,

  /* True AOR (average order revenue) */
  total_sales / NULLIF(total_orders, 0) AS average_order_revenue,

  /* Average monthly revenue (avoid divide by 0) */
  total_sales / NULLIF(GREATEST(TIMESTAMPDIFF(MONTH, first_order_date, last_order_date), 1), 0) AS average_monthly_revenue
FROM product_rollup
ORDER BY total_sales DESC;





































    
    